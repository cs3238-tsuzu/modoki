// Code generated by goagen v1.3.1, DO NOT EDIT.
//
// API "Modoki API": Application Contexts
//
// Command:
// $ goagen
// --design=github.com/cs3238-tsuzu/modoki/design
// --out=$(GOPATH)/src/github.com/cs3238-tsuzu/modoki
// --version=v1.3.1

package app

import (
	"context"
	"github.com/goadesign/goa"
	"net/http"
	"strconv"
	"unicode/utf8"
)

// CreateContainerContext provides the container create action context.
type CreateContainerContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Cmd         []string
	Entrypoint  []string
	Env         []string
	Image       string
	Name        string
	SslRedirect bool
	Volumes     []string
	WorkingDir  *string
}

// NewCreateContainerContext parses the incoming request URL and body, performs validations and creates the
// context used by the container controller create action.
func NewCreateContainerContext(ctx context.Context, r *http.Request, service *goa.Service) (*CreateContainerContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := CreateContainerContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramCmd := req.Params["cmd"]
	if len(paramCmd) > 0 {
		params := paramCmd
		rctx.Cmd = params
	}
	paramEntrypoint := req.Params["entrypoint"]
	if len(paramEntrypoint) > 0 {
		params := paramEntrypoint
		rctx.Entrypoint = params
	}
	paramEnv := req.Params["env"]
	if len(paramEnv) > 0 {
		params := paramEnv
		rctx.Env = params
	}
	paramImage := req.Params["image"]
	if len(paramImage) == 0 {
		err = goa.MergeErrors(err, goa.MissingParamError("image"))
	} else {
		rawImage := paramImage[0]
		rctx.Image = rawImage
	}
	paramName := req.Params["name"]
	if len(paramName) == 0 {
		err = goa.MergeErrors(err, goa.MissingParamError("name"))
	} else {
		rawName := paramName[0]
		rctx.Name = rawName
		if ok := goa.ValidatePattern(`^[a-zA-Z0-9_]+$`, rctx.Name); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`name`, rctx.Name, `^[a-zA-Z0-9_]+$`))
		}
		if utf8.RuneCountInString(rctx.Name) > 64 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`name`, rctx.Name, utf8.RuneCountInString(rctx.Name), 64, false))
		}
	}
	paramSslRedirect := req.Params["sslRedirect"]
	if len(paramSslRedirect) == 0 {
		rctx.SslRedirect = true
	} else {
		rawSslRedirect := paramSslRedirect[0]
		if sslRedirect, err2 := strconv.ParseBool(rawSslRedirect); err2 == nil {
			rctx.SslRedirect = sslRedirect
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("sslRedirect", rawSslRedirect, "boolean"))
		}
	}
	paramVolumes := req.Params["volumes"]
	if len(paramVolumes) > 0 {
		params := paramVolumes
		rctx.Volumes = params
	}
	paramWorkingDir := req.Params["workingDir"]
	if len(paramWorkingDir) > 0 {
		rawWorkingDir := paramWorkingDir[0]
		rctx.WorkingDir = &rawWorkingDir
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *CreateContainerContext) OK(r *GoaContainerCreateResults) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "vnd.application/goa.container.create.results+json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *CreateContainerContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// Conflict sends a HTTP response with status code 409.
func (ctx *CreateContainerContext) Conflict(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 409, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *CreateContainerContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// DownloadContainerContext provides the container download action context.
type DownloadContainerContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ID   *string
	Path *string
}

// NewDownloadContainerContext parses the incoming request URL and body, performs validations and creates the
// context used by the container controller download action.
func NewDownloadContainerContext(ctx context.Context, r *http.Request, service *goa.Service) (*DownloadContainerContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := DownloadContainerContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramID := req.Params["id"]
	if len(paramID) > 0 {
		rawID := paramID[0]
		rctx.ID = &rawID
	}
	paramPath := req.Params["path"]
	if len(paramPath) > 0 {
		rawPath := paramPath[0]
		rctx.Path = &rawPath
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *DownloadContainerContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "text/plain")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// NotFound sends a HTTP response with status code 404.
func (ctx *DownloadContainerContext) NotFound(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 404, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *DownloadContainerContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// RemoveContainerContext provides the container remove action context.
type RemoveContainerContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Force bool
	ID    string
}

// NewRemoveContainerContext parses the incoming request URL and body, performs validations and creates the
// context used by the container controller remove action.
func NewRemoveContainerContext(ctx context.Context, r *http.Request, service *goa.Service) (*RemoveContainerContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := RemoveContainerContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramForce := req.Params["force"]
	if len(paramForce) == 0 {
		rctx.Force = false
	} else {
		rawForce := paramForce[0]
		if force, err2 := strconv.ParseBool(rawForce); err2 == nil {
			rctx.Force = force
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("force", rawForce, "boolean"))
		}
	}
	paramID := req.Params["id"]
	if len(paramID) == 0 {
		err = goa.MergeErrors(err, goa.MissingParamError("id"))
	} else {
		rawID := paramID[0]
		rctx.ID = rawID
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *RemoveContainerContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "text/plain")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// NotFound sends a HTTP response with status code 404.
func (ctx *RemoveContainerContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// RunningContainer sends a HTTP response with status code 409.
func (ctx *RemoveContainerContext) RunningContainer() error {
	ctx.ResponseData.WriteHeader(409)
	return nil
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *RemoveContainerContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// StartContainerContext provides the container start action context.
type StartContainerContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ID string
}

// NewStartContainerContext parses the incoming request URL and body, performs validations and creates the
// context used by the container controller start action.
func NewStartContainerContext(ctx context.Context, r *http.Request, service *goa.Service) (*StartContainerContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := StartContainerContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramID := req.Params["id"]
	if len(paramID) == 0 {
		err = goa.MergeErrors(err, goa.MissingParamError("id"))
	} else {
		rawID := paramID[0]
		rctx.ID = rawID
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *StartContainerContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "text/plain")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// NotFound sends a HTTP response with status code 404.
func (ctx *StartContainerContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *StartContainerContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// StopContainerContext provides the container stop action context.
type StopContainerContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ID string
}

// NewStopContainerContext parses the incoming request URL and body, performs validations and creates the
// context used by the container controller stop action.
func NewStopContainerContext(ctx context.Context, r *http.Request, service *goa.Service) (*StopContainerContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := StopContainerContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramID := req.Params["id"]
	if len(paramID) == 0 {
		err = goa.MergeErrors(err, goa.MissingParamError("id"))
	} else {
		rawID := paramID[0]
		rctx.ID = rawID
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *StopContainerContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "text/plain")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// NotFound sends a HTTP response with status code 404.
func (ctx *StopContainerContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *StopContainerContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// UploadContainerContext provides the container upload action context.
type UploadContainerContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Payload *UploadPayload
}

// NewUploadContainerContext parses the incoming request URL and body, performs validations and creates the
// context used by the container controller upload action.
func NewUploadContainerContext(ctx context.Context, r *http.Request, service *goa.Service) (*UploadContainerContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := UploadContainerContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *UploadContainerContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "text/plain")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// NotFound sends a HTTP response with status code 404.
func (ctx *UploadContainerContext) NotFound(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 404, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *UploadContainerContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// AuthtypeVironContext provides the viron authtype action context.
type AuthtypeVironContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewAuthtypeVironContext parses the incoming request URL and body, performs validations and creates the
// context used by the viron controller authtype action.
func NewAuthtypeVironContext(ctx context.Context, r *http.Request, service *goa.Service) (*AuthtypeVironContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := AuthtypeVironContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *AuthtypeVironContext) OK(r VironauthtypeCollection) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.vironauthtype+json; type=collection")
	}
	if r == nil {
		r = VironauthtypeCollection{}
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// GetVironContext provides the viron get action context.
type GetVironContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewGetVironContext parses the incoming request URL and body, performs validations and creates the
// context used by the viron controller get action.
func NewGetVironContext(ctx context.Context, r *http.Request, service *goa.Service) (*GetVironContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := GetVironContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *GetVironContext) OK(r *Vironsetting) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.vironsetting+json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// SigninVironContext provides the viron signin action context.
type SigninVironContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Payload *SigninPayload
}

// NewSigninVironContext parses the incoming request URL and body, performs validations and creates the
// context used by the viron controller signin action.
func NewSigninVironContext(ctx context.Context, r *http.Request, service *goa.Service) (*SigninVironContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := SigninVironContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// NoContent sends a HTTP response with status code 204.
func (ctx *SigninVironContext) NoContent() error {
	ctx.ResponseData.WriteHeader(204)
	return nil
}

// Unauthorized sends a HTTP response with status code 401.
func (ctx *SigninVironContext) Unauthorized() error {
	ctx.ResponseData.WriteHeader(401)
	return nil
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *SigninVironContext) InternalServerError() error {
	ctx.ResponseData.WriteHeader(500)
	return nil
}
