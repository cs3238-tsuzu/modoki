// Code generated by goagen v1.3.1, DO NOT EDIT.
//
// API "Modoki API": Application Contexts
//
// Command:
// $ goagen
// --design=github.com/cs3238-tsuzu/modoki/design
// --out=$(GOPATH)/src/github.com/cs3238-tsuzu/modoki
// --version=v1.3.1

package app

import (
	"context"
	"github.com/goadesign/goa"
	"net/http"
	"strconv"
	"time"
	"unicode/utf8"
)

// CreateContainerContext provides the container create action context.
type CreateContainerContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Command     []string
	Entrypoint  []string
	Env         []string
	Image       string
	Name        string
	SslRedirect bool
	Volumes     []string
	WorkingDir  *string
}

// NewCreateContainerContext parses the incoming request URL and body, performs validations and creates the
// context used by the container controller create action.
func NewCreateContainerContext(ctx context.Context, r *http.Request, service *goa.Service) (*CreateContainerContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := CreateContainerContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramCommand := req.Params["command"]
	if len(paramCommand) > 0 {
		params := paramCommand
		rctx.Command = params
	}
	paramEntrypoint := req.Params["entrypoint"]
	if len(paramEntrypoint) > 0 {
		params := paramEntrypoint
		rctx.Entrypoint = params
	}
	paramEnv := req.Params["env"]
	if len(paramEnv) > 0 {
		params := paramEnv
		rctx.Env = params
	}
	paramImage := req.Params["image"]
	if len(paramImage) == 0 {
		err = goa.MergeErrors(err, goa.MissingParamError("image"))
	} else {
		rawImage := paramImage[0]
		rctx.Image = rawImage
	}
	paramName := req.Params["name"]
	if len(paramName) == 0 {
		err = goa.MergeErrors(err, goa.MissingParamError("name"))
	} else {
		rawName := paramName[0]
		rctx.Name = rawName
		if ok := goa.ValidatePattern(`^[a-zA-Z0-9_]+$`, rctx.Name); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`name`, rctx.Name, `^[a-zA-Z0-9_]+$`))
		}
		if utf8.RuneCountInString(rctx.Name) > 64 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`name`, rctx.Name, utf8.RuneCountInString(rctx.Name), 64, false))
		}
	}
	paramSslRedirect := req.Params["sslRedirect"]
	if len(paramSslRedirect) == 0 {
		rctx.SslRedirect = true
	} else {
		rawSslRedirect := paramSslRedirect[0]
		if sslRedirect, err2 := strconv.ParseBool(rawSslRedirect); err2 == nil {
			rctx.SslRedirect = sslRedirect
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("sslRedirect", rawSslRedirect, "boolean"))
		}
	}
	paramVolumes := req.Params["volumes"]
	if len(paramVolumes) > 0 {
		params := paramVolumes
		rctx.Volumes = params
	}
	paramWorkingDir := req.Params["workingDir"]
	if len(paramWorkingDir) > 0 {
		rawWorkingDir := paramWorkingDir[0]
		rctx.WorkingDir = &rawWorkingDir
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *CreateContainerContext) OK(r *GoaContainerCreateResults) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "vnd.application/goa.container.create.results+json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *CreateContainerContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// Conflict sends a HTTP response with status code 409.
func (ctx *CreateContainerContext) Conflict(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 409, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *CreateContainerContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// DownloadContainerContext provides the container download action context.
type DownloadContainerContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ID           string
	InternalPath string
}

// NewDownloadContainerContext parses the incoming request URL and body, performs validations and creates the
// context used by the container controller download action.
func NewDownloadContainerContext(ctx context.Context, r *http.Request, service *goa.Service) (*DownloadContainerContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := DownloadContainerContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramID := req.Params["id"]
	if len(paramID) == 0 {
		err = goa.MergeErrors(err, goa.MissingParamError("id"))
	} else {
		rawID := paramID[0]
		rctx.ID = rawID
	}
	paramInternalPath := req.Params["internalPath"]
	if len(paramInternalPath) == 0 {
		err = goa.MergeErrors(err, goa.MissingParamError("internalPath"))
	} else {
		rawInternalPath := paramInternalPath[0]
		rctx.InternalPath = rawInternalPath
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *DownloadContainerContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "text/plain")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// NotFound sends a HTTP response with status code 404.
func (ctx *DownloadContainerContext) NotFound(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 404, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *DownloadContainerContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// InspectContainerContext provides the container inspect action context.
type InspectContainerContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ID string
}

// NewInspectContainerContext parses the incoming request URL and body, performs validations and creates the
// context used by the container controller inspect action.
func NewInspectContainerContext(ctx context.Context, r *http.Request, service *goa.Service) (*InspectContainerContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := InspectContainerContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramID := req.Params["id"]
	if len(paramID) == 0 {
		err = goa.MergeErrors(err, goa.MissingParamError("id"))
	} else {
		rawID := paramID[0]
		rctx.ID = rawID
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *InspectContainerContext) OK(r *GoaContainerInspect) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "vpn.application/goa.container.inspect")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *InspectContainerContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *InspectContainerContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// ListContainerContext provides the container list action context.
type ListContainerContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewListContainerContext parses the incoming request URL and body, performs validations and creates the
// context used by the container controller list action.
func NewListContainerContext(ctx context.Context, r *http.Request, service *goa.Service) (*ListContainerContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := ListContainerContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *ListContainerContext) OK(r GoaContainerListEachCollection) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "vpn.application/goa.container.list.each; type=collection")
	}
	if r == nil {
		r = GoaContainerListEachCollection{}
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *ListContainerContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *ListContainerContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// LogsContainerContext provides the container logs action context.
type LogsContainerContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Follow     bool
	ID         string
	Since      *time.Time
	Stderr     bool
	Stdout     bool
	Tail       string
	Timestamps bool
	Until      *time.Time
}

// NewLogsContainerContext parses the incoming request URL and body, performs validations and creates the
// context used by the container controller logs action.
func NewLogsContainerContext(ctx context.Context, r *http.Request, service *goa.Service) (*LogsContainerContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := LogsContainerContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramFollow := req.Params["follow"]
	if len(paramFollow) == 0 {
		rctx.Follow = false
	} else {
		rawFollow := paramFollow[0]
		if follow, err2 := strconv.ParseBool(rawFollow); err2 == nil {
			rctx.Follow = follow
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("follow", rawFollow, "boolean"))
		}
	}
	paramID := req.Params["id"]
	if len(paramID) == 0 {
		err = goa.MergeErrors(err, goa.MissingParamError("id"))
	} else {
		rawID := paramID[0]
		rctx.ID = rawID
	}
	paramSince := req.Params["since"]
	if len(paramSince) > 0 {
		rawSince := paramSince[0]
		if since, err2 := time.Parse(time.RFC3339, rawSince); err2 == nil {
			tmp3 := &since
			rctx.Since = tmp3
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("since", rawSince, "datetime"))
		}
	}
	paramStderr := req.Params["stderr"]
	if len(paramStderr) == 0 {
		rctx.Stderr = false
	} else {
		rawStderr := paramStderr[0]
		if stderr, err2 := strconv.ParseBool(rawStderr); err2 == nil {
			rctx.Stderr = stderr
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("stderr", rawStderr, "boolean"))
		}
	}
	paramStdout := req.Params["stdout"]
	if len(paramStdout) == 0 {
		rctx.Stdout = false
	} else {
		rawStdout := paramStdout[0]
		if stdout, err2 := strconv.ParseBool(rawStdout); err2 == nil {
			rctx.Stdout = stdout
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("stdout", rawStdout, "boolean"))
		}
	}
	paramTail := req.Params["tail"]
	if len(paramTail) == 0 {
		rctx.Tail = "all"
	} else {
		rawTail := paramTail[0]
		rctx.Tail = rawTail
	}
	paramTimestamps := req.Params["timestamps"]
	if len(paramTimestamps) == 0 {
		rctx.Timestamps = false
	} else {
		rawTimestamps := paramTimestamps[0]
		if timestamps, err2 := strconv.ParseBool(rawTimestamps); err2 == nil {
			rctx.Timestamps = timestamps
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("timestamps", rawTimestamps, "boolean"))
		}
	}
	paramUntil := req.Params["until"]
	if len(paramUntil) > 0 {
		rawUntil := paramUntil[0]
		if until, err2 := time.Parse(time.RFC3339, rawUntil); err2 == nil {
			tmp7 := &until
			rctx.Until = tmp7
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("until", rawUntil, "datetime"))
		}
	}
	return &rctx, err
}

// NotFound sends a HTTP response with status code 404.
func (ctx *LogsContainerContext) NotFound(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 404, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *LogsContainerContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// RemoveContainerContext provides the container remove action context.
type RemoveContainerContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Force bool
	ID    string
}

// NewRemoveContainerContext parses the incoming request URL and body, performs validations and creates the
// context used by the container controller remove action.
func NewRemoveContainerContext(ctx context.Context, r *http.Request, service *goa.Service) (*RemoveContainerContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := RemoveContainerContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramForce := req.Params["force"]
	if len(paramForce) == 0 {
		rctx.Force = false
	} else {
		rawForce := paramForce[0]
		if force, err2 := strconv.ParseBool(rawForce); err2 == nil {
			rctx.Force = force
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("force", rawForce, "boolean"))
		}
	}
	paramID := req.Params["id"]
	if len(paramID) == 0 {
		err = goa.MergeErrors(err, goa.MissingParamError("id"))
	} else {
		rawID := paramID[0]
		rctx.ID = rawID
	}
	return &rctx, err
}

// NoContent sends a HTTP response with status code 204.
func (ctx *RemoveContainerContext) NoContent() error {
	ctx.ResponseData.WriteHeader(204)
	return nil
}

// NotFound sends a HTTP response with status code 404.
func (ctx *RemoveContainerContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// RunningContainer sends a HTTP response with status code 409.
func (ctx *RemoveContainerContext) RunningContainer() error {
	ctx.ResponseData.WriteHeader(409)
	return nil
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *RemoveContainerContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// StartContainerContext provides the container start action context.
type StartContainerContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ID string
}

// NewStartContainerContext parses the incoming request URL and body, performs validations and creates the
// context used by the container controller start action.
func NewStartContainerContext(ctx context.Context, r *http.Request, service *goa.Service) (*StartContainerContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := StartContainerContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramID := req.Params["id"]
	if len(paramID) == 0 {
		err = goa.MergeErrors(err, goa.MissingParamError("id"))
	} else {
		rawID := paramID[0]
		rctx.ID = rawID
	}
	return &rctx, err
}

// NoContent sends a HTTP response with status code 204.
func (ctx *StartContainerContext) NoContent() error {
	ctx.ResponseData.WriteHeader(204)
	return nil
}

// NotFound sends a HTTP response with status code 404.
func (ctx *StartContainerContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *StartContainerContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// StopContainerContext provides the container stop action context.
type StopContainerContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ID string
}

// NewStopContainerContext parses the incoming request URL and body, performs validations and creates the
// context used by the container controller stop action.
func NewStopContainerContext(ctx context.Context, r *http.Request, service *goa.Service) (*StopContainerContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := StopContainerContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramID := req.Params["id"]
	if len(paramID) == 0 {
		err = goa.MergeErrors(err, goa.MissingParamError("id"))
	} else {
		rawID := paramID[0]
		rctx.ID = rawID
	}
	return &rctx, err
}

// NoContent sends a HTTP response with status code 204.
func (ctx *StopContainerContext) NoContent() error {
	ctx.ResponseData.WriteHeader(204)
	return nil
}

// NotFound sends a HTTP response with status code 404.
func (ctx *StopContainerContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *StopContainerContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// UploadContainerContext provides the container upload action context.
type UploadContainerContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Payload *UploadPayload
}

// NewUploadContainerContext parses the incoming request URL and body, performs validations and creates the
// context used by the container controller upload action.
func NewUploadContainerContext(ctx context.Context, r *http.Request, service *goa.Service) (*UploadContainerContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := UploadContainerContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// NoContent sends a HTTP response with status code 204.
func (ctx *UploadContainerContext) NoContent() error {
	ctx.ResponseData.WriteHeader(204)
	return nil
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *UploadContainerContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *UploadContainerContext) NotFound(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 404, r)
}

// RequestEntityTooLarge sends a HTTP response with status code 413.
func (ctx *UploadContainerContext) RequestEntityTooLarge() error {
	ctx.ResponseData.WriteHeader(413)
	return nil
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *UploadContainerContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// AuthtypeVironContext provides the viron authtype action context.
type AuthtypeVironContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewAuthtypeVironContext parses the incoming request URL and body, performs validations and creates the
// context used by the viron controller authtype action.
func NewAuthtypeVironContext(ctx context.Context, r *http.Request, service *goa.Service) (*AuthtypeVironContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := AuthtypeVironContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *AuthtypeVironContext) OK(r VironauthtypeCollection) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.vironauthtype+json; type=collection")
	}
	if r == nil {
		r = VironauthtypeCollection{}
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// GetVironContext provides the viron get action context.
type GetVironContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewGetVironContext parses the incoming request URL and body, performs validations and creates the
// context used by the viron controller get action.
func NewGetVironContext(ctx context.Context, r *http.Request, service *goa.Service) (*GetVironContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := GetVironContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *GetVironContext) OK(r *Vironsetting) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.vironsetting+json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// SigninVironContext provides the viron signin action context.
type SigninVironContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Payload *SigninPayload
}

// NewSigninVironContext parses the incoming request URL and body, performs validations and creates the
// context used by the viron controller signin action.
func NewSigninVironContext(ctx context.Context, r *http.Request, service *goa.Service) (*SigninVironContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := SigninVironContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// NoContent sends a HTTP response with status code 204.
func (ctx *SigninVironContext) NoContent() error {
	ctx.ResponseData.WriteHeader(204)
	return nil
}

// Unauthorized sends a HTTP response with status code 401.
func (ctx *SigninVironContext) Unauthorized() error {
	ctx.ResponseData.WriteHeader(401)
	return nil
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *SigninVironContext) InternalServerError() error {
	ctx.ResponseData.WriteHeader(500)
	return nil
}
