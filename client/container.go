// Code generated by goagen v1.3.1, DO NOT EDIT.
//
// API "Modoki API": container Resource Client
//
// Command:
// $ goagen
// --design=github.com/cs3238-tsuzu/modoki/design
// --out=$(GOPATH)/src/github.com/cs3238-tsuzu/modoki
// --version=v1.3.1

package client

import (
	"context"
	"fmt"
	"net/http"
	"net/url"
	"strconv"
)

// CreateContainerPath computes a request path to the create action of container.
func CreateContainerPath() string {

	return fmt.Sprintf("/api/v1/container/create")
}

// create a new container
func (c *Client) CreateContainer(ctx context.Context, path string, image string, name string, cmd []string, entrypoint []string, env []string, volumes []string, workingDir *string) (*http.Response, error) {
	req, err := c.NewCreateContainerRequest(ctx, path, image, name, cmd, entrypoint, env, volumes, workingDir)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewCreateContainerRequest create the request corresponding to the create action endpoint of the container resource.
func (c *Client) NewCreateContainerRequest(ctx context.Context, path string, image string, name string, cmd []string, entrypoint []string, env []string, volumes []string, workingDir *string) (*http.Request, error) {
	scheme := c.Scheme
	if scheme == "" {
		scheme = "https"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	values := u.Query()
	values.Set("image", image)
	values.Set("name", name)
	for _, p := range cmd {
		tmp9 := p
		values.Add("cmd", tmp9)
	}
	for _, p := range entrypoint {
		tmp10 := p
		values.Add("entrypoint", tmp10)
	}
	for _, p := range env {
		tmp11 := p
		values.Add("env", tmp11)
	}
	for _, p := range volumes {
		tmp12 := p
		values.Add("volumes", tmp12)
	}
	if workingDir != nil {
		values.Set("workingDir", *workingDir)
	}
	u.RawQuery = values.Encode()
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	if c.JWTSigner != nil {
		if err := c.JWTSigner.Sign(req); err != nil {
			return nil, err
		}
	}
	return req, nil
}

// RemoveContainerPath computes a request path to the remove action of container.
func RemoveContainerPath() string {

	return fmt.Sprintf("/api/v1/container/remove")
}

// remove a container
func (c *Client) RemoveContainer(ctx context.Context, path string, force bool, id string) (*http.Response, error) {
	req, err := c.NewRemoveContainerRequest(ctx, path, force, id)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewRemoveContainerRequest create the request corresponding to the remove action endpoint of the container resource.
func (c *Client) NewRemoveContainerRequest(ctx context.Context, path string, force bool, id string) (*http.Request, error) {
	scheme := c.Scheme
	if scheme == "" {
		scheme = "https"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	values := u.Query()
	tmp13 := strconv.FormatBool(force)
	values.Set("force", tmp13)
	values.Set("id", id)
	u.RawQuery = values.Encode()
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	if c.JWTSigner != nil {
		if err := c.JWTSigner.Sign(req); err != nil {
			return nil, err
		}
	}
	return req, nil
}

// StartContainerPath computes a request path to the start action of container.
func StartContainerPath() string {

	return fmt.Sprintf("/api/v1/container/start")
}

// start a container
func (c *Client) StartContainer(ctx context.Context, path string, id string) (*http.Response, error) {
	req, err := c.NewStartContainerRequest(ctx, path, id)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewStartContainerRequest create the request corresponding to the start action endpoint of the container resource.
func (c *Client) NewStartContainerRequest(ctx context.Context, path string, id string) (*http.Request, error) {
	scheme := c.Scheme
	if scheme == "" {
		scheme = "https"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	values := u.Query()
	values.Set("id", id)
	u.RawQuery = values.Encode()
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	if c.JWTSigner != nil {
		if err := c.JWTSigner.Sign(req); err != nil {
			return nil, err
		}
	}
	return req, nil
}

// StopContainerPath computes a request path to the stop action of container.
func StopContainerPath() string {

	return fmt.Sprintf("/api/v1/container/stop")
}

// stop a container
func (c *Client) StopContainer(ctx context.Context, path string, id string) (*http.Response, error) {
	req, err := c.NewStopContainerRequest(ctx, path, id)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewStopContainerRequest create the request corresponding to the stop action endpoint of the container resource.
func (c *Client) NewStopContainerRequest(ctx context.Context, path string, id string) (*http.Request, error) {
	scheme := c.Scheme
	if scheme == "" {
		scheme = "https"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	values := u.Query()
	values.Set("id", id)
	u.RawQuery = values.Encode()
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	if c.JWTSigner != nil {
		if err := c.JWTSigner.Sign(req); err != nil {
			return nil, err
		}
	}
	return req, nil
}
